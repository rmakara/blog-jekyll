---
layout: post
title: New post
image: /assets/20200825_header.jpg
description: My story, on how emotions helped me to be a little bit better engineer. What can we do to bring some of the end-users' pain to our daily life? Is it worth it?
---

# Starting from scratch

Couple of weeks ago, we've left our previous low-engineering-quality project. We managed to leave it just after a successful go live. Thanks to our commitment we delivered it on time. Our company wants to award us for this accomplishment and decided to give us the opportunity to start the new project/product from scratch. We managed to stop cooperating with existing customer and we got into totally new team. Our new team is made of young and dynamic people with more experienced product owner, who understands all the aspects of agile manifesto. Sounds familiar?

# Time luxury

We are super existed with the new idea. We are coming up with the name for the initiative, creating code repository, writing down the coding standards and the definition of done. We're setting 2 week long sprints and we create a long backlog of user stories. 

In the next weeks, we're coming up with the abstraction layers to overcome all the issues, that we faced in the previous application when it came to cooperation with decision-changing customer. We are super proud of 99% of unit tests coverage and continious deployment applied. Every time we merge something to the master branch, it is getting automatically deployed to the environment! Works like magic.

Every two weeks, we're doing a sprint review for the product owner and we're showing all the exciting mechanisms, which will allow us to keep the highest quality of the software. Our UK-based product owner is proud of us and after the successful sprint review he says "excellent job team".

# Common pitfalls

After 2-3 months, we discover that we managed to keep committing the code to the repository but we're still far from delivering the critical user journey. We were very satisfied about all the tools, that we used and engineering practices we applied. We've made all of it with no end-user in mind. The codebase got bigger and our test environment was automatically getting the next releases but the sanity testing of the whole solutions today takes about 2 minutes because the end-user cannot complete the journey to get any value from the solution. So the set of the features is pretty much - limited.

Based on the UI designs that we've got, we implemented all of the features for 3 pages. We even managed to apply feature flags engine, which will allow our future customer to turn on and off specific features on these pages. Critical user journey still doesn't work.

We found a good excuse to why we were showing just the codebase on a screensharing session during the sprint reviews. We were not given important implementation from 3rd party software, which was blocking us from getting the data to fulfill our databse with something meaningful, so we couldn't populate the frontend with any data. So that was not possible to be displayed, nor used.

The abstraction layers, that we created required 1 week of refactoring sprint but we ended up with the possibility for limitless extensions, when PO will ask for these.

Unfortunately, we cannot understand why the boss of our PO asks about going live the next month. 

# Customer's priorities

After working with more than 50 customers, I observed the patterns in their expectations. Usually, people from outside of the scrum team in customer's organisation tend to value more boring stuff much higher than doing all the green field activities. 

People, who drive the business (e.g. sales, operations, c-levels, account managers) tend to value the elements, which directly corespond to one of the following outcomes:

* Rising customer satisfaction.
* Rising employee satisfaction.

Both of these usually lead to rising the revenue in a long-term. This is where the brownfield projects with good documentation, stable deployment and release strategies, customer support, bug fixing, proper design and user training usually step in.

Reality shows, that the goals and values of the most newly created scrum/development teams are strongly different from the customer ones.

For the business people, even at the huge scale companies, when the new opportunity appears they simply want to get it done. If the complex software doesn't allow them to release the new solution in a matter of days then in many cases they see the simple Zapier integration with Google Spreadsheet might be valuable. After they got the light weight working solution then they are super happy about the continuation of this idea by implementing a high quality system for it. 

# Starting a project with end-user in mind

What would change if instead of being green-field-focused we would become customer and end-user focused? It is most likely, that we would get a better understanding of where the money comes from. The software is starting to make the money once it is released to production. So all of the activities that we perform should lead to filling the needs of end-users, customers or employees. Once we understand it, we will come up with the proper perspective on enabling technology. The purpose of technology is "to enable". 

The best engineering practices and keeping the software quality as high as we can are the best steps to reduce the cost in the long-term. However, we need to keep in mind that all the practices, which we apply need to come from the user needs. Not from our own engineering desires or biases.

# Building products with no operational experience

Coming back to the beginning of this article, when we mentioned that our developer managed to leave the project just after going live with it. 

The best understanding of customer's perspective doesn't come up from being in 50 projects during the development phase. As long as the project is not being used by the real users, we are just making guesses on how our implementation meets the needs.

We may ask the questions: How our implementation will help in achieving operational excellence after releasing it to production? How are we going to maintain the application and if all of the applied code-level techniques will enable us to keep implementing the new features or the post-live reality will require us to focus on maintenance in 100%? How are we going to release its new versions? Will we be able to deploy every day? Will the bug fixing become a pain in the ass?

Usually, the engineering teams focus a lot on developing. Asking the questions on its maintenance from the very beginning of the project will help a lot in the phase when the solution starts making money. Eventually, maybe it will make the decision about staying in the project after going live with it much easier? We will not want to run away from what we've created and what we are blaming our decision-changing customer for?

If you're given the opportunity to maintain and develop the live system then this is the best opportunity to learn a lot about the real software development, management and delivery techniques. Just do your best to keep being inspired and focus on helping the end-user by providing them the best experience they can imagine.

# Iterations and prioritization to the rescue

All the battles around "real Scrum" and "not-by-the book Scrum" led us to focusing on the wrong thing. Mechanics and practices. 

Agile Manifesto tells us that our ability to respond to constant changes in close collaboration with our customer is the key. What is missing in it is the end-user and proper understanding of the "working software".

Even when working on the new software systems before running them live, we may imagine that we already have our end-users and we want to set our highest priority on satisfying them by early and continuous delivery. That means, by applying the proper prioritisation, we may implement the critical journey for the specific user persona first. Wrap it with the best engineering practices required for a given phase and then iterate from it. 

"Working software" means - really, the working software - the one, which might be presented during the sprint reviews. Working software means: the end-user may use it to achieve something he/she needs. 

# Green field - What to keep in mind?

* Setup test environment as early as possible and share it with your customer. Use it to practice frequent and stable deployments.
* Focus on definying and delivering the cirtical user journey first.
* No big architecture upfront doesn't mean no architecture at all. Starting with the code and repository is not always the best first step. Workshop may work.
* People will not understand something just because you give them the explanation. Give the team the questions to answer on the early stages and help them to find the answers by themselves; even if you already know them.
* Keep codebase quality as high as possible, but do not over-engineer for something that you think you will need in the future. Let the technology be driven by the end-user needs.
* In most cases, when working in waterfall-kind-of-project, iterations are the best tool for reducing the project's risk. Critical aspect here it is to remember about the working software, after each iteration.
* Create a software that you will want to maintain.
* Communicate the goals and expectations. Make the team understand the business context, not just the descriptions of the Jira tickets.